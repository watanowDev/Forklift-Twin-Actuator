#pragma once

#include <functional>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

namespace PatliteLED {

// ============================================
// 이벤트 핸들러 타입 정의
// C#의 EventHandler<TPayload> 델리게이트와 유사
// ============================================
template<typename TPayload>
using EventHandler = std::function<void(const TPayload&)>;

// ============================================
// 구독 토큰 (구독 취소를 위한 핸들)
// ============================================
class SubscriptionToken {
public:
    SubscriptionToken(int id) : id_(id) {}
    int GetId() const { return id_; }
    
private:
    int id_;
};

// ============================================
// 이벤트 클래스 - 특정 타입의 이벤트 관리
// C#의 PubSubEvent<TPayload>와 유사
// ============================================
template<typename TPayload>
class Event {
public:
    // 이벤트 구독
    std::shared_ptr<SubscriptionToken> Subscribe(EventHandler<TPayload> handler) {
        std::lock_guard<std::mutex> lock(mutex_);
        int token_id = next_token_id_++;
        handlers_[token_id] = handler;
        return std::make_shared<SubscriptionToken>(token_id);
    }
    
    // 이벤트 구독 취소
    void Unsubscribe(std::shared_ptr<SubscriptionToken> token) {
        if (token) {
            std::lock_guard<std::mutex> lock(mutex_);
            handlers_.erase(token->GetId());
        }
    }
    
    // 이벤트 발행 (모든 구독자에게 알림)
    void Publish(const TPayload& payload) {
        std::lock_guard<std::mutex> lock(mutex_);
        for (auto& pair : handlers_) {
            try {
                pair.second(payload);
            }
            catch (...) {
                // 예외 발생 시 무시 (C# 원본과 동일)
            }
        }
    }

private:
    std::map<int, EventHandler<TPayload>> handlers_;
    std::mutex mutex_;
    int next_token_id_ = 0;
};

// ============================================
// 이벤트 애그리게이터 (싱글톤)
// C#의 Prism IEventAggregator와 유사
// ============================================
class EventAggregator {
public:
    static EventAggregator& GetInstance() {
        static EventAggregator instance;
        return instance;
    }
    
    // 특정 타입의 이벤트 객체 가져오기
    template<typename TPayload>
    std::shared_ptr<Event<TPayload>> GetEvent() {
        const char* type_name = typeid(TPayload).name();
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = events_.find(type_name);
        if (it == events_.end()) {
            auto event = std::make_shared<Event<TPayload>>();
            events_[type_name] = event;
            return event;
        }
        
        return std::static_pointer_cast<Event<TPayload>>(it->second);
    }

private:
    EventAggregator() = default;
    EventAggregator(const EventAggregator&) = delete;
    EventAggregator& operator=(const EventAggregator&) = delete;
    
    std::map<std::string, std::shared_ptr<void>> events_;
    std::mutex mutex_;
};

} // namespace PatliteLED
